import dotenv from "dotenv";
dotenv.config();

import { ApolloServer, gql, PubSub } from "apollo-server-express";
import { readFileSync } from "fs";
import express from "express";
import Loggers from "./Loggers";
import jwt from "jsonwebtoken";

Loggers.mainLogger.info("Starting starship-server");

import resolvers from "./resolvers/resolvers";
import { connect } from "mongoose";
import IUserToken from "./util/IUserToken";
import Context from "./util/Context";
import Loaders from "./util/Loaders";
import http from "http";
import { RedisCache } from "apollo-server-cache-redis";
import yn from "yn";
import fs from "fs";
import PubSubContainer from "./util/PubSubContainer";
import Users from "./database/Users";
import { v4 as uuidv4 } from 'uuid';
import SysInfo from "./util/SysInfo";

SysInfo.generateSysInfo();

let url = process.env.MONGO_URL;

if(process.env.DATABASE_URL) {
  url = process.env.DATABASE_URL;
}

connect(url, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  useFindAndModify: false,
  useCreateIndex: true,
  sslCA: process.env.MONGO_CA ? [fs.readFileSync(process.env.MONGO_CA)] : null
}).then(async () => {
  Loggers.dbLogger.info("Connected to database sucessfully");
    Loggers.dbLogger.info("Setting up DB schema");
    require('./database/database');
    require('./database/indexes');
    Loggers.apolloLogger.info("Starting Apollo");
    Loggers.apolloLogger.info("Setting up PubSub");
    PubSubContainer.pubSub = new PubSub();
    const app = express();
    if(!process.env.REDIS_SERVER) {
      Loggers.mainLogger.warn("RUNNING IN DEVELOPMENT MODE, NOT USING REDIS");
    }
    Loggers.apolloLogger.info("Verifying schema integrity");
    let schema = "";
    if(yn(process.env.DEVELOPMENT)) {
      schema = readFileSync('src/starship-schema/schema.graphql', 'utf8');
    } else {
      schema = readFileSync('dist/starship-schema/schema.graphql', 'utf8');
    }
    if(!schema.startsWith("# starship-schema ")) {
      Loggers.apolloLogger.fatal("Invalid schema header. Expected '# starship-schema (version)', got '" + schema.split("\n")[0] + "'.");
      Loggers.mainLogger.fatal("Exiting...");
      process.exit(3);
    }
    if(!schema.startsWith("# starship-schema " + SysInfo.sysInfo.schemaVersion)) {
      Loggers.apolloLogger.fatal("Server schema version mismatch. Verify that schema.graphql is the correct version.");
      Loggers.apolloLogger.fatal("sysInfo.schemaVersion: " + SysInfo.sysInfo.schemaVersion);
      Loggers.apolloLogger.fatal("schema.graphql version: " + schema.split("\n")[0].split("starship-schema ")[1]);
      Loggers.mainLogger.fatal("Exiting...");
      process.exit(2);
    }

    let uuid = uuidv4();

    // setup session stuff
    if(!fs.existsSync("./uuid.txt")) {
      Loggers.mainLogger.info(`First startup, new UUID is ${uuid}`);
      Loggers.mainLogger.info(`UUID saved`);
      fs.writeFileSync("./uuid.txt", uuid);
    } else {
      uuid = readFileSync("./uuid.txt").toString();
      Loggers.mainLogger.info(`UUID loaded from uuid.txt is ${uuid}`);
    }

    Loggers.dbLogger.info("Clearing UUID from user sessions");
    await Users.findOneAndUpdate({sessions: uuid}, {$pull: {sessions: uuid}}, {new: true});

    const typeDefs = gql`${schema}`;
    const server = new ApolloServer({
      typeDefs,
      resolvers,
      context: ({req, connection}) => {
        let user: IUserToken = null;
        let token: string = null;

        if(req) {
          if (req.headers.authorization !== undefined && req.headers.authorization.includes("Bearer")) {
            token = req.headers.authorization;
          }

          if(token) {
            token = token.replace('Bearer ', '');
            user = jwt.verify(token, process.env.SECRET) as IUserToken;
            if(user.id == undefined) {
              user = null;
            }
          }

          const ctx = new Context();
          
          ctx.user = user;
          ctx.loaders = new Loaders();
  
          return ctx;
        } else {
          // subscription contexts are generated by onConnect
          if(connection.context) {
            return connection.context as Context;
          }
        }
      },
      tracing: yn(process.env.DEVELOPMENT),
      cache: (process.env.REDIS_SERVER ? new RedisCache({
        host: process.env.REDIS_SERVER,
        port: Number(process.env.REDIS_PORT),
        password: process.env.REDIS_PASSWORD,
        username: process.env.REDIS_USERNAME,
        tls: {}
      }) : undefined),
      subscriptions: {
        onConnect: async (connectionParams, ws) => {
          const { onclose } = ws;
          
          // eslint-disable-next-line
          if (connectionParams["Authorization"] !== undefined && connectionParams["Authorization"].includes("Bearer")) {
            // eslint-disable-next-line
            let token = connectionParams["Authorization"] as string;

            if(token) {
              token = token.replace('Bearer ', '');
              const user = jwt.verify(token, process.env.SECRET) as IUserToken;
              if(user.id != undefined) {
                const userForContext = await Users.findOneAndUpdate({_id: user.id}, {$push: {sessions: uuid}}, {new: true});
                // this isn't a super great idea, but I couldn't think of
                // anything better
                // TODO: if apollo makes an API to do this correctly then we should do it correctly
                // they have disconnected, decrement sessionCount
                ws.onclose = async (e) => {
                  // eslint-disable-next-line
                  // remove one single element from the array of sessions
                  await Users.findOneAndUpdate({_id: user.id, sessions: uuid}, {"$unset": {"sessions.$": ""}}, {new: true});
                  await Users.findOneAndUpdate({_id: user.id}, {$pull: {sessions: null}}, {new: true});
      
                  if(onclose) {
                    onclose(e);
                  }
                };

                const ctx = new Context();
          
                ctx.user = user;
                ctx.subscriptionUser = userForContext;
                // we can't use these but they're here anyways
                ctx.loaders = new Loaders();
                return ctx;
              }
            }
          }
        }
      }
    });

    server.applyMiddleware({ app });

    app.get('/', (req, res) => {
      res.json(SysInfo.sysInfo);
    });

    const httpServer = http.createServer(app);
    server.installSubscriptionHandlers(httpServer);
    httpServer.listen({ port: Number(process.env.PORT) }, () => {
      Loggers.apolloLogger.info(`Server up at http://localhost:${process.env.PORT}${server.graphqlPath}`);
    });
}).catch((error) => {
  Loggers.dbLogger.error(error);
  Loggers.mainLogger.fatal("Exiting...");
  process.exit(1);
});
